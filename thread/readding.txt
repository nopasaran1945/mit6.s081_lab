首先看一下跟线程有关的对象，尽管在xv6里边，线程并没有专门作为一个对象被定义出来(类似struct proc明确被定义并赋予各种变量和状态)，但是其设计是有包含到这一点的：
来看接下来的一个对象定义：
// Saved registers for kernel context switches.
struct context {
  uint64 ra;
  uint64 sp;

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  uint64 s9;
  uint64 s10;
  uint64 s11;
};
可以看到，xv6在kernel\proc.h里边专门定义了一个以供线程切换使用的对象，context对象，它保存了线程运行所需要的pc，stack pointer（函数调用积存的stack），在保存ra和pc后
它还定义了callee-saved的寄存器。每当xv6切换一次context，就是完成了一次线程的切换（指令与运行上下文的切换），就是切换到不同的任务上了，更具体的我们
可以在之后再来进行说明。
再来看strcut cpu：
struct cpu {
  struct proc *proc;          // The process running on this cpu, or null.
  struct context context;     // swtch() here to enter scheduler().
  int noff;                   // Depth of push_off() nesting.
  int intena;                 // Were interrupts enabled before push_off()?
};
比较显而易见的是,每个cpu都被专门赋予了一个context，这一点是为什么我们会在接下来进行说明。
用接下来的一个常见例子，我们就能说明xv6如何切换线程：
首先，假设进程0运行在其用户进程中而不是在内核中，CPU0正在运行它，然后触发了一次定时器中断，开始跳入内核,一开始是进入trapoline，然后在保存用户进程的状态到trapframe
后，它便会进入到usertrap,usertrap中做了一些工作,比如修改stval，修改stvec，以保证接下来遇到的中断都会进入到kerneltrap。处理完上述的工作后，usertrap根据devintr判断
到这是一个定时器中断，然后它切换了一次上下文，接下来进入的上下文在哪？是的，就是在cpu的context内，它会切换到每一个CPU都具有的调度器线程中，然后进入swtch函数来进行
线程切换，切换到另一个线程中，而另一个线程必然也是通过swtch函数进行线程切换，所以其最后会返回对应的中断处理程序或者是系统调用中，在通过一系列的usertrapret函数
等等来跳回用户空间。
