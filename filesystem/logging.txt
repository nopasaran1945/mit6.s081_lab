//loggging part 
xv6对logging层进行设计的原因在于保证写入磁盘的操作序列是原子的，这样就不会在崩溃时出现各种各样奇怪的不一致性结果,linux对日志操作有着额外的optimization但是我们
暂时在下一节再来谈这个。
从前面的磁盘块的文件系统组织,我们可以看到在superblock之后就是logging block。header块后跟着连续的日志块，或者我们称作更新块副本。header包含了一个扇区号数组，每个扇区号
都会对应一个logging block,header包含日志块的数量。磁盘上header 块中的数量要么是0,表示日志内没有事务，要不然就是非0，日志块内还有一个完整的提交事务，并且包含
指定数量的日志块。logging 的基本想法大概类似buffer，对整个文件系统进行写入操作并不会直接操作virtio disk而是先写入log,
在一个事务下的所有更新操作完成之前是不可以将对应log 下的count抹除的，这一点有什么好处呢。来分析接下来的一个流程
write 33 // the first syscall to write the root inode(//type dir)
write 45  //set bit map 
write 256
可以确定一点的是，将这些全部挂在log下，无论在哪一步Crash，系统都会把这些进行重写，也就是说，不影响这一系列操作的原子性。并且也不会影响其他的disk block。
整体的流程大概如下：
log write ：将系统调用对block的操作和写入数据 写在 log block 内。
commit op:在某一个时间点中，当文件系统的操作结束之后， logging 可以commit 文件系统的操作,并且记录操作的数量。
install log:将log的block content移到调用原本要写入的block。
clean log:一旦以上系统调用的操作全部写完，OK，那么就将操作计数清0。

清理下整体流程，以sysopen为例。begin_op()代表事务的开始，end_op()代表事务的结束。
可以确定的一点是，中间所有试图写磁盘的操作最终都会先写到Log内，来看看具体的代码：
ialloc(kernel/fs.c)内并不具有直接bwrite的函数，而是log_write();
log_write();
log write 的代码最开始的错误判断跳过，来到正常区域
//log absorbtion
首先Log write试图在logheader里搜索，如果已经有这个block的buffer在事务中了，那么不需要再重复，直接跳过就好，将前后的对同一个磁盘块的操作合并了。
这就是absorbtion,如果事务中没有对这个blockno对应的磁盘块的写入请求操作，那么就会增加header 的n，然后用bpin来（固定），这是为了防止当buffer cache满后撤回block时，假如选择到了事务中的block块，那么在还没完成其他操作时就会写磁盘，这种情况是我们不允许发生的。
//记住一个点，我们上述的logwrite全部是在内存内的数据结构修改。
endop():
commit:
write_log():函数就干了一件事情，遍历header，并且读一个log block buf,就写一个buf到log block内，此时，请注意，headerblock没有改变，如果在write head之前crash
那么等于没提交事务，因为内存中的log block buf和header已经掉电丢失了。而header也没被写入，因此，事务等于没发生。
write_head():commmit point 
这个时间点后:write_head已经向log header的磁盘块传输完了，可以说即便crash，file system也能察觉到header内有transactions
仍然会跑去传输。
至于install_trans，就没太多需要讲的，把log对应的块送入就好了。
接下来，来看看initlog,发生crash后的recovering function。
